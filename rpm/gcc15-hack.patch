--- libada/Makefile.in.jj	2019-01-09 13:01:18.015608205 +0100
+++ libada/Makefile.in	2019-01-11 18:16:23.441726931 +0100
@@ -71,18 +71,40 @@ version := $(shell @get_gcc_base_ver@ $(
 libsubdir := $(libdir)/gcc/$(target_noncanonical)/$(version)$(MULTISUBDIR)
 ADA_RTS_DIR=$(GCC_DIR)/ada/rts$(subst /,_,$(MULTISUBDIR))
 
+DEFAULTMULTIFLAGS :=
+ifeq ($(MULTISUBDIR),)
+targ:=$(subst -, ,$(target))
+arch:=$(word 1,$(targ))
+ifeq ($(words $(targ)),2)
+osys:=$(word 2,$(targ))
+else
+osys:=$(word 3,$(targ))
+endif
+ifeq ($(strip $(filter-out i%86 x86_64 powerpc% ppc% s390% sparc% linux%, $(arch) $(osys))),)
+ifeq ($(shell $(CC) $(CFLAGS) -print-multi-os-directory),../lib64)
+DEFAULTMULTIFLAGS := -m64
+else
+ifeq ($(strip $(filter-out s390%, $(arch))),)
+DEFAULTMULTIFLAGS := -m31
+else
+DEFAULTMULTIFLAGS := -m32
+endif
+endif
+endif
+endif
+
 # exeext should not be used because it's the *host* exeext.  We're building
 # a *target* library, aren't we?!?  Likewise for CC.  Still, provide bogus
 # definitions just in case something slips through the safety net provided
 # by recursive make invocations in gcc/ada/Makefile.in
 LIBADA_FLAGS_TO_PASS = \
         "MAKEOVERRIDES=" \
-        "LDFLAGS=$(LDFLAGS)" \
+        "LDFLAGS=$(LDFLAGS) $(DEFAULTMULTIFLAGS)" \
         "LN_S=$(LN_S)" \
         "SHELL=$(SHELL)" \
-        "GNATLIBFLAGS=$(GNATLIBFLAGS) $(MULTIFLAGS)" \
-        "GNATLIBCFLAGS=$(GNATLIBCFLAGS) $(MULTIFLAGS)" \
-        "GNATLIBCFLAGS_FOR_C=$(GNATLIBCFLAGS_FOR_C) $(MULTIFLAGS)" \
+        "GNATLIBFLAGS=$(GNATLIBFLAGS) $(MULTIFLAGS) $(DEFAULTMULTIFLAGS)" \
+        "GNATLIBCFLAGS=$(GNATLIBCFLAGS) $(MULTIFLAGS) $(DEFAULTMULTIFLAGS)" \
+        "GNATLIBCFLAGS_FOR_C=$(GNATLIBCFLAGS_FOR_C) $(MULTIFLAGS) $(DEFAULTMULTIFLAGS)" \
         "PICFLAG_FOR_TARGET=$(PICFLAG)" \
         "THREAD_KIND=$(THREAD_KIND)" \
         "TRACE=$(TRACE)" \
@@ -93,7 +115,7 @@ LIBADA_FLAGS_TO_PASS = \
         "exeext=.exeext.should.not.be.used " \
 	'CC=the.host.compiler.should.not.be.needed' \
 	"GCC_FOR_TARGET=$(CC)" \
-        "CFLAGS=$(CFLAGS)"
+        "CFLAGS=$(CFLAGS) $(DEFAULTMULTIFLAGS)"
 
 .PHONY: libada gnatlib gnatlib-shared gnatlib-sjlj gnatlib-zcx osconstool
 
--- config-ml.in.jj	2019-01-09 12:50:16.646501448 +0100
+++ config-ml.in	2019-01-11 18:16:23.442726914 +0100
@@ -511,6 +511,8 @@ multi-do:
 				ADAFLAGS="$(ADAFLAGS) $${flags}" \
 				prefix="$(prefix)" \
 				exec_prefix="$(exec_prefix)" \
+				mandir="$(mandir)" \
+				infodir="$(infodir)" \
 				GOCFLAGS="$(GOCFLAGS) $${flags}" \
 				GDCFLAGS="$(GDCFLAGS) $${flags}" \
 				CXXFLAGS="$(CXXFLAGS) $${flags}" \
--- libcpp/macro.cc.jj	2019-01-09 13:01:21.420552123 +0100
+++ libcpp/macro.cc	2024-11-30 13:16:41.163056391 +0100
@@ -3680,8 +3680,6 @@ static cpp_macro *
 create_iso_definition (cpp_reader *pfile)
 {
   bool following_paste_op = false;
-  const char *paste_op_error_msg =
-    N_("%<##%> cannot appear at either end of a macro expansion");
   unsigned int num_extra_tokens = 0;
   unsigned nparms = 0;
   cpp_hashnode **params = NULL;
@@ -3809,7 +3807,9 @@ create_iso_definition (cpp_reader *pfile
 	     function-like macros, but not at the end.  */
 	  if (following_paste_op)
 	    {
-	      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);
+	      cpp_error (pfile, CPP_DL_ERROR,
+			 "%<##%> cannot appear at either end of a macro "
+			 "expansion");
 	      goto out;
 	    }
 	  if (!vaopt_tracker.completed ())
@@ -3824,7 +3824,9 @@ create_iso_definition (cpp_reader *pfile
 	     function-like macros, but not at the beginning.  */
 	  if (macro->count == 1)
 	    {
-	      cpp_error (pfile, CPP_DL_ERROR, paste_op_error_msg);
+	      cpp_error (pfile, CPP_DL_ERROR,
+			 "%<##%> cannot appear at either end of a macro "
+			 "expansion");
 	      goto out;
 	    }
 
--- libcpp/expr.cc.jj	2019-01-09 13:01:22.415535734 +0100
+++ libcpp/expr.cc	2024-11-30 13:14:52.468583689 +0100
@@ -874,50 +874,54 @@ cpp_classify_number (cpp_reader *pfile,
       if ((result & CPP_N_WIDTH) == CPP_N_LARGE
 	  && CPP_OPTION (pfile, cpp_warn_long_long))
         {
-          const char *message = CPP_OPTION (pfile, cplusplus)
-				? N_("use of C++11 long long integer constant")
-		                : N_("use of C99 long long integer constant");
-
 	  if (CPP_OPTION (pfile, c99))
-            cpp_warning_with_line (pfile, CPP_W_LONG_LONG, virtual_location,
-				   0, message);
+            cpp_warning_with_line (pfile, CPP_W_LONG_LONG, virtual_location, 0,
+				   CPP_OPTION (pfile, cplusplus)
+				   ? N_("use of C++11 long long integer "
+					"constant")
+				   : N_("use of C99 long long integer "
+					"constant"));
           else
             cpp_pedwarning_with_line (pfile, CPP_W_LONG_LONG,
-				      virtual_location, 0, message);
+				      virtual_location, 0,
+				      CPP_OPTION (pfile, cplusplus)
+				      ? N_("use of C++11 long long integer "
+					   "constant")
+				      : N_("use of C99 long long integer "
+					   "constant"));
         }
 
       if ((result & CPP_N_SIZE_T) == CPP_N_SIZE_T
 	  && !CPP_OPTION (pfile, size_t_literals))
-       {
-	  const char *message
-	    = (result & CPP_N_UNSIGNED) == CPP_N_UNSIGNED
-	      ? N_("use of C++23 %<size_t%> integer constant")
-	      : N_("use of C++23 %<make_signed_t<size_t>%> integer constant");
-	  cpp_warning_with_line (pfile, CPP_W_SIZE_T_LITERALS,
-				 virtual_location, 0, message);
-       }
+	cpp_warning_with_line (pfile, CPP_W_SIZE_T_LITERALS,
+			       virtual_location, 0,
+			       (result & CPP_N_UNSIGNED) == CPP_N_UNSIGNED
+				? N_("use of C++23 %<size_t%> integer "
+				     "constant")
+				: N_("use of C++23 %<make_signed_t<size_t>%> "
+				     "integer constant"));
 
       if ((result & CPP_N_BITINT) != 0
 	  && CPP_OPTION (pfile, cpp_warn_c11_c23_compat) != 0)
 	{
 	  if (CPP_OPTION (pfile, cpp_warn_c11_c23_compat) > 0)
 	    {
-	      const char *message = N_("ISO C does not support literal "
-				       "%<wb%> suffixes before C23");
 	      if (CPP_PEDANTIC (pfile) && !CPP_OPTION (pfile, true_false))
 		cpp_pedwarning_with_line (pfile, CPP_W_C11_C23_COMPAT,
-					  virtual_location, 0, message);
+					  virtual_location, 0,
+					  "ISO C does not support literal "
+					  "%<wb%> suffixes before C23");
 	      else
 		cpp_warning_with_line (pfile, CPP_W_C11_C23_COMPAT,
-				       virtual_location, 0, message);
-	    }
-	  else if (!CPP_OPTION (pfile, true_false))
-	    {
-	      const char *message = N_("ISO C does not support literal "
+				       virtual_location, 0,
+				       "ISO C does not support literal "
 				       "%<wb%> suffixes before C23");
-	      cpp_pedwarning_with_line (pfile, CPP_W_PEDANTIC,
-					virtual_location, 0, message);
 	    }
+	  else if (!CPP_OPTION (pfile, true_false))
+	    cpp_pedwarning_with_line (pfile, CPP_W_PEDANTIC,
+				      virtual_location, 0,
+				      "ISO C does not support literal "
+				      "%<wb%> suffixes before C23");
 	}
 
       result |= CPP_N_INTEGER;
